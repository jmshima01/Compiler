// package main

// import (
// 	"fmt"
// 	"os"
// )

// var LLTable = [38][47]int{
// {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
// {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,2,3,0,0,0,0,0,3,0,0,0,0,2,0,0,0,0,0,0,0,0,3,0,0},
// {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0},
// {0,0,0,0,0,6,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
// {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,9,0,0,0,0,0,0,0,11,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
// {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,12,0,0,0,0,0,12,0,0,0,0,0,0,0,0,0,0,0,0,0,13,0,0},
// {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,0,0,0,0,15,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
// {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,18,0,0,0,0,0,0,0,18,0,18,0,0,0,0,0,0,0,0,0,0,0,0,0,17,0,0,0,0,0},
// {0,0,20,0,0,0,0,0,0,0,0,0,0,0,0,0,19,19,0,0,0,0,0,0,0,19,0,19,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
// {0,0,22,0,0,21,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
// {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,23,0,0,0},
// {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,25,0,0,0,0,0,25,0,0,25,0,0,0,0,25,0,0,0,0,0,24,0,25,0,25,0,0},
// {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,26,0,0,0,0,0,0},
// {0,0,0,0,0,27,0,0,0,28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
// {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
// {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,30,0,0,0,0,0,0,0,0,0},
// {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
// {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,33,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
// {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,34,0,0,0,0,0,34,0,0,34,0,0,0,0,34,0,0,0,0,0,0,0,34,0,35,0,0},
// {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,39,0,0,0,0,0,37,0,0,36,0,0,0,0,40,0,0,0,0,0,0,0,38,0,0,0,0},
// {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,41,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
// {0,0,0,0,0,0,0,0,0,0,0,43,0,42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
// {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,44,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
// {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,46,45,0,0,0,0,46,0,0,46,0,0,0,0,46,0,0,0,0,0,0,0,46,0,0,0,0},
// {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,47,0,0,0,0},
// {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
// {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,49,0,0,0,0,0,0,0,0,0,0,0,0},
// {0,50,0,0,0,0,50,0,0,51,0,0,0,0,0,50,0,0,0,0,0,0,50,0,0,50,0,0,50,0,0,50,50,0,0,0,50,50,50,50,0,0,0,0,0,50,0},
// {0,52,0,0,0,0,52,0,0,0,0,0,0,0,0,52,0,0,0,0,0,0,52,0,0,52,0,0,52,0,0,52,52,0,0,0,52,52,52,52,0,0,0,0,0,52,0},
// {53,0,54,53,53,54,53,0,53,54,53,53,53,0,54,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,53,0,0,0,0,0,0,0,0,0,0,0,0,0},
// {0,60,0,0,0,0,61,0,0,0,0,0,0,0,0,58,0,0,0,0,0,0,57,0,0,58,0,0,55,0,0,57,59,0,0,0,56,59,57,57,0,0,0,0,0,61,0},
// {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,63,0,0,0,0,62,0,0,0,0,0,0,0,0,0},
// {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,64,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
// {0,65,66,0,0,0,65,0,0,0,0,0,0,0,0,65,0,0,0,0,0,0,65,0,0,65,0,0,65,0,0,65,65,0,0,0,65,65,65,65,0,0,0,0,0,65,0},
// {0,0,68,0,0,67,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
// {73,0,0,71,69,0,70,0,72,0,75,77,76,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,74,0,0,0,0,0,0,0,0,0,0,0,0,0},
// {0,0,0,0,0,0,78,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,79,0},
// {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,81,0,0,0,0,0,0,0,0,82,0,0,0,0,0,0,83,80,0,0,0,0,0,0,0}}

// var ruleLookup = map[int]ProductionRule{
// 	77: ProductionRule{lhs:"Op", rhs:[]string{"="}},
// 	18: ProductionRule{lhs:"SubroutineDecType", rhs:[]string{"Type"}},
// 	41: ProductionRule{lhs:"LetStatement", rhs:[]string{"let","VarName","LetExpressionCheck","=","Expression",";"}},
// 	47: ProductionRule{lhs:"WhileStatement", rhs:[]string{"while","(","Expression","}","{","Statements","}"}},
// 	65: ProductionRule{lhs:"ExpressionList", rhs:[]string{"Expression","ExpressionListExt"}},
// 	69: ProductionRule{lhs:"Op", rhs:[]string{"+"}},
// 	78: ProductionRule{lhs:"UnaryOp", rhs:[]string{"-"}},
// 	1: ProductionRule{lhs:"Class", rhs:[]string{"class","ClassName","{","ClassVarDec","SubroutineDec","}","$"}},
// 	23: ProductionRule{lhs:"SubroutineBody", rhs:[]string{"{","SubroutineBodyVarDec","Statements","}"}},
// 	42: ProductionRule{lhs:"LetExpressionCheck", rhs:[]string{"[","Expression","]"}},
// 	56: ProductionRule{lhs:"Term", rhs:[]string{"[]stringconstant"}},
// 	57: ProductionRule{lhs:"Term", rhs:[]string{"KeywordConstant"}},
// 	11: ProductionRule{lhs:"Type", rhs:[]string{"ClassName"}},
// 	72: ProductionRule{lhs:"Op", rhs:[]string{"/"}},
// 	75: ProductionRule{lhs:"Op", rhs:[]string{"<"}},
// 	27: ProductionRule{lhs:"VarDecExt", rhs:[]string{",","VarName","VarDecExt"}},
// 	43: ProductionRule{lhs:"LetExpressionCheck", rhs:[]string{"lambda"}},
// 	59: ProductionRule{lhs:"Term", rhs:[]string{"SubroutineCall"}},
// 	76: ProductionRule{lhs:"Op", rhs:[]string{">"}},
// 	35: ProductionRule{lhs:"Statements", rhs:[]string{"lambda"}},
// 	58: ProductionRule{lhs:"Term", rhs:[]string{"VarName"}},
// 	80: ProductionRule{lhs:"KeywordConstant", rhs:[]string{"true"}},
// 	9: ProductionRule{lhs:"Type", rhs:[]string{"char"}},
// 	10: ProductionRule{lhs:"Type", rhs:[]string{"boolean"}},
// 	17: ProductionRule{lhs:"SubroutineDecType", rhs:[]string{"void"}},
// 	26: ProductionRule{lhs:"VarDec", rhs:[]string{"var","Type","VarName","VarDecExt",";"}},
// 	34: ProductionRule{lhs:"Statements", rhs:[]string{"Statement","Statements"}},
// 	54: ProductionRule{lhs:"ExpressionTerms", rhs:[]string{"lambda"}},
// 	67: ProductionRule{lhs:"ExpressionListExt", rhs:[]string{",","Expression","ExpressionListExt"}},
// 	81: ProductionRule{lhs:"KeywordConstant", rhs:[]string{"false"}},
// 	21: ProductionRule{lhs:"ParameterListExt", rhs:[]string{",","Type","VarName","ParameterListExt"}},
// 	28: ProductionRule{lhs:"VarDecExt", rhs:[]string{"lambda"}},
// 	38: ProductionRule{lhs:"Statement", rhs:[]string{"WhileStatement"}},
// 	40: ProductionRule{lhs:"Statement", rhs:[]string{"ReturnStatement"}},
// 	51: ProductionRule{lhs:"ReturnExpressionCheck", rhs:[]string{"lambda"}},
// 	8: ProductionRule{lhs:"Type", rhs:[]string{"int"}},
// 	24: ProductionRule{lhs:"SubroutineBodyVarDec", rhs:[]string{"VarDec","SubroutineBodyVarDec"}},
// 	50: ProductionRule{lhs:"ReturnExpressionCheck", rhs:[]string{"Expression"}},
// 	68: ProductionRule{lhs:"ExpressionListExt", rhs:[]string{"lambda"}},
// 	63: ProductionRule{lhs:"SubroutineCall", rhs:[]string{"SubroutineCallName",".","SubroutineName","(","ExpressionList","}"}},
// 	79: ProductionRule{lhs:"UnaryOp", rhs:[]string{"~"}},
// 	6: ProductionRule{lhs:"ExtraVarExt", rhs:[]string{",","VarName","ExtraVarExt"}},
// 	16: ProductionRule{lhs:"SubroutineDecCFM", rhs:[]string{"method"}},
// 	29: ProductionRule{lhs:"ClassName", rhs:[]string{"identifier"}},
// 	36: ProductionRule{lhs:"Statement", rhs:[]string{"LetStatement"}},
// 	37: ProductionRule{lhs:"Statement", rhs:[]string{"IfStatement"}},
// 	2: ProductionRule{lhs:"ClassVarDec", rhs:[]string{"ClassVarDecSF","Type","VarName","ExtraVarExt",";","ClassVarDec"}},
// 	53: ProductionRule{lhs:"ExpressionTerms", rhs:[]string{"Op","Term","ExpressionTerms"}},
// 	82: ProductionRule{lhs:"KeywordConstant", rhs:[]string{"null"}},
// 	46: ProductionRule{lhs:"ElseStatment", rhs:[]string{"lambda"}},
// 	71: ProductionRule{lhs:"Op", rhs:[]string{"*"}},
// 	5: ProductionRule{lhs:"ClassVarDecSF", rhs:[]string{"field"}},
// 	12: ProductionRule{lhs:"SubroutineDec", rhs:[]string{"SubroutineDecCFM","SubroutineDecType","SubroutineName","(","ParameterList","}","SubroutineBody","SubroutineDec"}},
// 	15: ProductionRule{lhs:"SubroutineDecCFM", rhs:[]string{"function"}},
// 	25: ProductionRule{lhs:"SubroutineBodyVarDec", rhs:[]string{"lambda"}},
// 	31: ProductionRule{lhs:"VarName", rhs:[]string{"identifier"}},
// 	22: ProductionRule{lhs:"ParameterListExt", rhs:[]string{"lambda"}},
// 	48: ProductionRule{lhs:"DoStatement", rhs:[]string{"do","SubroutineCall",";"}},
// 	61: ProductionRule{lhs:"Term", rhs:[]string{"UnaryOp","Term"}},
// 	64: ProductionRule{lhs:"SubroutineCallName", rhs:[]string{"objectname"}},
// 	74: ProductionRule{lhs:"Op", rhs:[]string{"pipe"}},
// 	7: ProductionRule{lhs:"ExtraVarExt", rhs:[]string{"lambda"}},
// 	32: ProductionRule{lhs:"VarName", rhs:[]string{"ArrayName"}},
// 	60: ProductionRule{lhs:"Term", rhs:[]string{"(","Expression","}"}},
// 	62: ProductionRule{lhs:"SubroutineCall", rhs:[]string{"SubroutineName","(","ExpressionList","}"}},
// 	4: ProductionRule{lhs:"ClassVarDecSF", rhs:[]string{"static"}},
// 	14: ProductionRule{lhs:"SubroutineDecCFM", rhs:[]string{"constructor"}},
// 	30: ProductionRule{lhs:"SubroutineName", rhs:[]string{"subroutinename"}},
// 	44: ProductionRule{lhs:"IfStatement", rhs:[]string{"if","(","Expression","}","{","Statements","}","ElseStatment"}},
// 	55: ProductionRule{lhs:"Term", rhs:[]string{"integerconstant"}},
// 	3: ProductionRule{lhs:"ClassVarDec", rhs:[]string{"lambda"}},
// 	19: ProductionRule{lhs:"ParameterList", rhs:[]string{"Type","VarName","ParameterListExt"}},
// 	66: ProductionRule{lhs:"ExpressionList", rhs:[]string{"lambda"}},
// 	70: ProductionRule{lhs:"Op", rhs:[]string{"-"}},
// 	83: ProductionRule{lhs:"KeywordConstant", rhs:[]string{"this"}},
// 	13: ProductionRule{lhs:"SubroutineDec", rhs:[]string{"lambda"}},
// 	45: ProductionRule{lhs:"ElseStatment", rhs:[]string{"else","{","Statements","}"}},
// 	49: ProductionRule{lhs:"ReturnStatement", rhs:[]string{"return","ReturnExpressionCheck",";"}},
// 	52: ProductionRule{lhs:"Expression", rhs:[]string{"Term","ExpressionTerms"}},
// 	73: ProductionRule{lhs:"Op", rhs:[]string{"&"}},
// 	20: ProductionRule{lhs:"ParameterList", rhs:[]string{"lambda"}},
// 	33: ProductionRule{lhs:"ArrayName", rhs:[]string{"array","[","Expression","]"}},
// 	39: ProductionRule{lhs:"Statement", rhs:[]string{"DoStatement"}},
// }


// func JackLLParse(tokenFile string) *Node{
	
	
// 	fmt.Println("=======================LL table driven parsing============")
	
// 	tokenStream := readTokens(tokenFile)

// 	for _, v := range tokenStream {
// 		fmt.Println(v)
// 	}

// 	S := make(stack, 0)
// 	Q := make(queue, 0)
// 	S = append(S, "Class")
// 	for i, v := range tokenStream {
// 		if v.tokenType == "identifier" {
// 			if tokenStream[i+1].value == "(" {
// 				Q.push(token{value: v.value, tokenType: "subroutinename"})
// 			} else if tokenStream[i+1].value == "." {
// 				Q.push(token{value: v.value, tokenType: "objectname"})
// 			} else if tokenStream[i+1].value == "[" {
// 				Q.push(token{value: v.value, tokenType: "array"})
// 			} else {
// 				Q.push(v)
// 			}

// 		} else if v.tokenType == "stringConst" {
// 			Q.push(token{value: v.value, tokenType: "stringconstant"})
// 		} else if v.tokenType == "integerConst" {
// 			Q.push(token{value: v.value, tokenType: "integerconstant"})
// 		} else {
// 			Q.push(v)
// 		}

// 	}
// 	Q.push(token{value: "$", tokenType: "$"})
// 	fmt.Println("---------------")
// 	for _, v := range Q {
// 		fmt.Println(v)
// 	}

// 	root := makeNode("ROOT", nil, 0)
// 	current := root
// 	current.debug()
// 	uniqueID := 1
// 	for {
// 		if S.isEmpty() {
// 			if !Q.isEmpty() {
// 				fmt.Println("syntax error:", Q)
// 				os.Exit(2)
// 			}

// 			break
// 		}

// 		fmt.Println("S:", S)
// 		fmt.Println("Q:", Q)

// 		s := S.peek()
// 		q := ""
// 		t := Q.peek()

// 		if t.tokenType == "keyword" || t.tokenType == "symbol" {
// 			q = t.value
// 		} else {
// 			q = t.tokenType
// 		}

// 		if s == "<*>" {

// 			S.pop()

// 			// SDT Ast conversion:
// 			switch current.data {
// 			case "ArrayName":
// 				current = current.parent
// 				newChildren := make([]*Node, 0)
// 				for _, v := range current.children {
// 					if v.data != "ArrayName" {
// 						newChildren = append(newChildren, v)
// 					} else {
// 						for _,x := range v.children{
// 							x.parent = current
// 						}
// 						newChildren = append(newChildren, v.children...)
// 					}
// 				}
// 				current.children = newChildren

// 			case "ClassName":
// 				current.data = current.children[0].data
// 				current.id = current.children[0].id
// 				current.children = nil
// 				current = current.parent
			
// 			case "SubroutineCallName":
// 				current.data = current.children[0].data
// 				current.id = current.children[0].id
// 				current.children = nil
// 				current = current.parent
// 			case "SubroutineName":
// 				current.data = current.children[0].data
// 				current.id = current.children[0].id
// 				current.children = nil
// 				current = current.parent
// 			case "Type":
// 				current.data = current.children[0].data
// 				current.id = current.children[0].id
// 				current.children = nil
// 				current = current.parent
// 			case "ClassVarDecSF":
// 				current.data = current.children[0].data
// 				current.id = current.children[0].id
// 				current.children = nil
// 				current = current.parent
// 			case "SubroutineDecCFM":
// 				current.data = current.children[0].data
// 				current.id = current.children[0].id
// 				current.children = nil
// 				current = current.parent

// 			case "SubroutineDecType":
// 				current.data = current.children[0].data
// 				current.id = current.children[0].id
// 				current.children = nil
// 				current = current.parent
// 			case "KeywordConstant":
// 				current.data = current.children[0].data
// 				current.id = current.children[0].id
// 				current.children = nil
// 				current = current.parent
			
// 			case "Term":
// 				current = current.parent
// 				newChildren := make([]*Node, 0)
// 				for _, v := range current.children {
// 					if v.data != "Term" {
// 						newChildren = append(newChildren, v)
// 					} else {
// 						for _,x := range v.children{
// 							x.parent = current
// 						}
// 						newChildren = append(newChildren, v.children...)
// 					}
// 				}
// 				current.children = newChildren

// 			case "Expression":
// 				newChildren := make([]*Node, 0)
// 				for _, v := range current.children {

// 					if v.data != ")" && v.data != "(" {
// 						newChildren = append(newChildren, v)
// 					}
// 				}
// 				current.children = newChildren
// 				current = current.parent

// 			case "Statement":
// 				current = current.parent
// 				newChildren := make([]*Node, 0)
// 				for _, v := range current.children {
// 					if v.data != "Statement" {
// 						newChildren = append(newChildren, v)
// 					} else {
// 						for _,x := range v.children{
// 							x.parent = current
// 						}
// 						newChildren = append(newChildren, v.children...)
// 					}
// 				}
// 				current.children = newChildren

// 			case "ExpressionTerms":
// 				if current.children[0].data == "lambda" {
// 					current.data = current.children[0].data
// 					current.id = current.children[0].id
// 					current.children = nil
// 					current = current.parent
// 					current.children = current.children[:len(current.children)-1]
// 				} else {
// 					current = current.parent
// 					newChildren := make([]*Node, 0)
// 					for _, v := range current.children {
// 						if v.data != "ExpressionTerms" {
// 							newChildren = append(newChildren, v)
// 						} else {
// 							for _,x := range v.children{
// 								x.parent = current
// 							}
// 							newChildren = append(newChildren, v.children...)
// 						}
// 					}
// 					current.children = newChildren
// 				}

// 			case "SubroutineBodyVarDec":
// 				if current.children[0].data == "lambda" {
// 					current.data = current.children[0].data
// 					current.id = current.children[0].id
// 					current.children = nil
// 					current = current.parent
// 					current.children = current.children[:len(current.children)-1]
// 				} else {
// 					current = current.parent
// 					newChildren := make([]*Node, 0)
// 					for _, v := range current.children {
// 						if v.data != "SubroutineBodyVarDec" {
// 							newChildren = append(newChildren, v)
// 						} else {
// 							for _,x := range v.children{
// 								x.parent = current
// 							}
// 							newChildren = append(newChildren, v.children...)
// 						}
// 					}
// 					current.children = newChildren

// 				}
// 			case "ExtraVarExt":
// 				if current.children[0].data == "lambda" {
// 					current.data = current.children[0].data
// 					current.id = current.children[0].id
// 					current.children = nil
// 					current = current.parent
// 					current.children = current.children[:len(current.children)-1]
// 				} else {
// 					current = current.parent
// 					newChildren := make([]*Node, 0)
// 					for _, v := range current.children {
// 						if v.data != "ExtraVarExt" {
// 							newChildren = append(newChildren, v)
// 						} else {
// 							for _,x := range v.children{
// 								x.parent = current
// 							}
// 							newChildren = append(newChildren, v.children...)
// 						}
// 					}
// 					current.children = newChildren
// 				}
// 			case "Statements":
// 				if current.children[0].data == "lambda" {
// 					current.data = current.children[0].data
// 					current.id = current.children[0].id
// 					current.children = nil
// 					current = current.parent
// 					current.children = current.children[:len(current.children)-1]
// 				} else {
// 					current = current.parent
// 					newChildren := make([]*Node, 0)
// 					for _, v := range current.children {
// 						if v.data != "Statements" {
// 							newChildren = append(newChildren, v)
// 						} else {
// 							for _,x := range v.children{
// 								x.parent = current
// 							}
// 							newChildren = append(newChildren, v.children...)
// 						}
// 					}
// 					current.children = newChildren

// 				}
// 			case "LetExpressionCheck":
// 				if current.children[0].data == "lambda" {
// 					current.data = current.children[0].data
// 					current.id = current.children[0].id
// 					current.children = nil
// 					current = current.parent
// 					current.children = current.children[:len(current.children)-1]
// 				} else {
// 					current = current.parent
// 					newChildren := make([]*Node, 0)
// 					for _, v := range current.children {
// 						if v.data != "LetExpressionCheck" {
// 							newChildren = append(newChildren, v)
// 						} else {
// 							for _,x := range v.children{
// 								x.parent = current
// 							}
// 							newChildren = append(newChildren, v.children...)
// 						}
// 					}
// 					current.children = newChildren
// 				}

// 			case "ReturnExpressionCheck":
// 				if current.children[0].data == "lambda" {
// 					current.data = current.children[0].data
// 					current.id = current.children[0].id
// 					current.children = nil
// 					current = current.parent
// 					current.children = current.children[:len(current.children)-1]
// 				} else {
// 					current = current.parent
// 					newChildren := make([]*Node, 0)
// 					for _, v := range current.children {
// 						if v.data != "ReturnExpressionCheck" {
// 							newChildren = append(newChildren, v)
// 						} else {
// 							for _,x := range v.children{
// 								x.parent = current
// 							}
// 							newChildren = append(newChildren, v.children...)
// 						}
// 					}
// 					current.children = newChildren
// 				}
// 			case "ExpressionList":
// 				if current.children[0].data == "lambda" {
// 					current.data = current.children[0].data
// 					current.id = current.children[0].id
// 					current.children = nil
// 					current = current.parent
// 					current.children = current.children[:len(current.children)-1]
// 				} else {

// 					current = current.parent
// 				}
// 			case "ParameterList":
// 				if current.children[0].data == "lambda" {
// 					current.data = current.children[0].data
// 					current.id = current.children[0].id
// 					current.children = nil
// 					current = current.parent
// 					current.children = current.children[:len(current.children)-1]
// 				} else {

// 					current = current.parent
// 				}
// 			case "ClassVarDec":
// 				if current.children[0].data == "lambda" {
// 					current.data = current.children[0].data
// 					current.id = current.children[0].id
// 					current.children = nil
// 					current = current.parent
// 					current.children = current.children[:len(current.children)-1]
// 				} else {
// 					newChildren := make([]*Node, 0)
// 					for _, v := range current.children {
// 						if v.data == "," || v.data == ";" {
// 							continue
// 						}
// 						newChildren = append(newChildren, v)

// 					}
// 					current.children = newChildren
// 					current = current.parent

// 				}
// 			case "SubroutineDec":
// 				if current.children[0].data == "lambda" {
// 					current.data = current.children[0].data
// 					current.id = current.children[0].id
// 					current.children = nil
// 					current = current.parent
// 					current.children = current.children[:len(current.children)-1]
// 				} else {
// 					newChildren := make([]*Node, 0)
// 					for _, v := range current.children {
// 						if v.data == "(" || v.data == ")" {
// 							continue
// 						}
// 						newChildren = append(newChildren, v)

// 					}
// 					current.children = newChildren
// 					current = current.parent
// 				}
// 			case "VarDecExt":
// 				if current.children[0].data == "lambda" {
// 					current.data = current.children[0].data
// 					current.id = current.children[0].id
// 					current.children = nil
// 					current = current.parent
// 					current.children = current.children[:len(current.children)-1]
// 				} else {
// 					current = current.parent
// 					newChildren := make([]*Node, 0)
// 					for _, v := range current.children {
// 						if v.data != "VarDecExt" {
// 							newChildren = append(newChildren, v)
// 						} else {
// 							for _, x := range v.children {
// 								x.parent = current
// 								if x.data != "," {
// 									newChildren = append(newChildren, x)
// 								}
// 							}

// 						}
// 					}
// 					current.children = newChildren
// 				}

// 			case "ExpressionListExt":
// 				if current.children[0].data == "lambda" {
// 					current.data = current.children[0].data
// 					current.id = current.children[0].id
// 					current.children = nil
// 					current = current.parent
// 					current.children = current.children[:len(current.children)-1]
// 				} else {
// 					current = current.parent
// 					newChildren := make([]*Node, 0)
// 					for _, v := range current.children {
// 						if v.data != "ExpressionListExt" {
// 							newChildren = append(newChildren, v)
// 						} else {
// 							for _, x := range v.children {
// 								x.parent = current
// 								if x.data != "," {
// 									newChildren = append(newChildren, x)
// 								}
// 							}

// 						}
// 					}
// 					current.children = newChildren
// 				}
// 			case "ParameterListExt":
// 				if current.children[0].data == "lambda" {
// 					current.data = current.children[0].data
// 					current.id = current.children[0].id
// 					current.children = nil
// 					current = current.parent
// 					current.children = current.children[:len(current.children)-1]
// 				} else {
// 					current = current.parent
// 					newChildren := make([]*Node, 0)
// 					for _, v := range current.children {
// 						if v.data != "ParameterListExt" {
// 							newChildren = append(newChildren, v)
// 						} else {
// 							for _, x := range v.children {
// 								x.parent = current
// 								if x.data != "," {
// 									newChildren = append(newChildren, x)
// 								}
// 							}

// 						}
// 					}
// 					current.children = newChildren
// 				}

// 			case "ElseStatment":
// 				if current.children[0].data == "lambda" {
// 					current.data = current.children[0].data
// 					current.id = current.children[0].id
// 					current.children = nil
// 					current = current.parent
// 					current.children = current.children[:len(current.children)-1]
// 				} else {
// 					newChildren := make([]*Node, 0)
// 					for _, v := range current.children {
// 						if v.data == "{" || v.data == "}" || v.data == "else" {
// 							continue
// 						}
// 						newChildren = append(newChildren, v)

// 					}
// 					current.children = newChildren
// 					current = current.parent
// 				}

// 			case "DoStatement":
// 				current = current.parent
// 				newChildren := make([]*Node, 0)
// 				for _, v := range current.children {
// 					if v.data != "DoStatement" {
// 						newChildren = append(newChildren, v)
// 					} else {
// 						for _, x := range v.children {
// 							x.parent = current
// 							if x.data != "do" && x.data != ";" {
// 								newChildren = append(newChildren, x)
// 							}
// 						}

// 					}
// 				}
// 				current.children = newChildren
// 				current.children[0].data = "DoStatement"

// 			case "LetStatement":
// 				newChildren := make([]*Node, 0)
// 				for _, v := range current.children {
// 					if v.data == "let" || v.data == ";" || v.data == "=" {
// 						continue
// 					}
// 					newChildren = append(newChildren, v)

// 				}
// 				current.children = newChildren
// 				current = current.parent

// 			case "WhileStatement":
// 				newChildren := make([]*Node, 0)
// 				for _, v := range current.children {
// 					if v.data == "while" || v.data == "(" || v.data == ")" || v.data == "{" || v.data == "}" {
// 						continue
// 					}
// 					newChildren = append(newChildren, v)

// 				}
// 				current.children = newChildren
// 				current = current.parent
			
// 			case "VarDec":
// 				current.children = current.children[1 : len(current.children)-1]
// 				current = current.parent
			
// 			case "ReturnStatement":
// 				if len(current.children) == 2 {
// 					current.children = nil
// 				} else {
// 					current.children = current.children[1:2]
// 				}
// 				current = current.parent
			
// 			case "SubroutineBody":
// 				current.children = current.children[1 : len(current.children)-1]
// 				current = current.parent
			
// 			case "SubroutineCall":
// 				newChildren := make([]*Node, 0)
// 				for _, v := range current.children {
// 					if v.data == "." || v.data == "(" || v.data == ")" {
// 						continue
// 					}
// 					newChildren = append(newChildren, v)

// 				}
// 				current.children = newChildren
// 				current = current.parent

// 			case "Class":
// 				newChildren := make([]*Node, 0)
// 				for _, v := range current.children {
// 					if v.data == "{" || v.data == "}" || v.data == "class" || v.data == "$" {
// 						continue
// 					}
// 					newChildren = append(newChildren, v)

// 				}
// 				current.children = newChildren
// 				current = current.parent
			
// 			case "IfStatement":
// 				newChildren := make([]*Node, 0)
// 				for _, v := range current.children {
// 					if v.data == "{" || v.data == "}" || v.data == "(" || v.data == ")" || v.data == "if" {
// 						continue
// 					}
// 					newChildren = append(newChildren, v)

// 				}
// 				current.children = newChildren
// 				current = current.parent

			
// 			default:
// 				current = current.parent
// 			}

// 			continue
// 		}

// 		if s == "lambda" {
// 			S.pop()
// 			lambNode := makeNode("lambda", current, uniqueID)
// 			addChild(current, lambNode)
// 			current.debug()
// 			uniqueID++
// 			continue
// 		}

// 		if isTerminal(s) || s == "$" {
// 			if s == q {
				
// 				if t.tokenType == "stringconstant" || t.tokenType == "integerconstant"{
// 					v := makeNode(t.value, current, uniqueID)
// 					uniqueID++
// 					term := makeNode(t.tokenType, current, uniqueID)
// 					addChild(term,v)
// 					uniqueID++
// 					addChild(current,term)
// 				} else{
// 					term := makeNode(t.value, current, uniqueID)
// 					addChild(current, term)
// 					uniqueID++
// 				}
// 				S.pop()
// 				Q.popfront()
// 				current.debug()

// 			} else {
// 				fmt.Println("syntax error: s!=q", s, q)
// 				os.Exit(2)
// 			}
			
// 			continue
// 		}

// 		nextRule, found := ruleLookup[LLTable[rowLookup[s]][columnLookup[q]]]
// 		if !found {

// 			fmt.Println("Parsing Error: (No such token in LL table or associated rule)", s, q, Q)
// 			fmt.Println("-----")
// 			fmt.Println(s, S)
// 			os.Exit(2)
// 		}

// 		fmt.Println("fetching rule...", nextRule)
// 		top := S.pop()
// 		newNode := makeNode(top, current, uniqueID)
// 		addChild(current, newNode)
// 		current.debug()

// 		current = newNode
// 		uniqueID++
// 		// add rule in reverse to stack...
// 		S = append(S, "<*>") // end of production
// 		for i := len(nextRule.rhs) - 1; i >= 0; i-- {
// 			S = append(S, nextRule.rhs[i])
// 		}
// 	}
// 	S = nil
// 	Q = nil
// 	current.debug()
// 	fmt.Println("============")
// 	// printTree(current)
// 	ast := current.children[0]
// 	// g := ""
// 	// graphiz:=*(toGraphiz(current,&g))

// 	nodeInfo := ""
// 	nodeInfo = *(genNodeInfo(ast, &nodeInfo))

// 	edgeInfo := ""
// 	edgeInfo = *(genEdgeInfo(ast, &edgeInfo))

// 	toGraphiz := nodeInfo + "\n" + edgeInfo
// 	writeToFile("parsetree.txt", toGraphiz)
// 	fmt.Println(toGraphiz)
// 	fmt.Println("======================= CODE GEN =====================")
// 	printTree(ast)
// 	VMcode := ""
// 	VMcode = *(codeGen2(ast,&VMcode))
// 	fmt.Println(G)
// 	fmt.Println(L)
// 	fmt.Println("\nVMcode:")
	
// 	return ast
// }
