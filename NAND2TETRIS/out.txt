map[&:true (:true ):true *:true +:true ,:true -:true .:true /:true ;:true <:true =:true >:true [:true ]:true array:true boolean:true char:true class:true constructor:true do:true else:true false:true field:true function:true identifier:true if:true int:true integerconstant:true let:true method:true null:true objectname:true pipe:true return:true static:true stringconstant:true subroutinename:true this:true true:true var:true void:true while:true {:true }:true ~:true]
map[Class:true ClassName:true ClassVarDec:true ClassVarDecSF:true DoStatement:true Expression:true ExpressionList:true ExpressionListExt:true ExpressionTerms:true ExtraVarExt:true IfElseCheck:true IfStatement:true KeywordConstant:true LetExpressionCheck:true LetStatement:true Op:true ParameterList:true ParameterListExt:true ReturnExpressionCheck:true ReturnStatement:true Statement:true Statements:true SubroutineBody:true SubroutineBodyVarDec:true SubroutineCall:true SubroutineCallName:true SubroutineDec:true SubroutineDecCFM:true SubroutineDecType:true SubroutineName:true Term:true Type:true UnaryOp:true VarDec:true VarDecExt:true VarName:true WhileStatement:true]
++++++++++++
{Class [class ClassName { ClassVarDec SubroutineDec } $]}
{ClassVarDec [ClassVarDecSF Type VarName ExtraVarExt ; ClassVarDec]}
{ClassVarDec [lambda]}
{ClassVarDecSF [static]}
{ClassVarDecSF [field]}
{ExtraVarExt [, VarName ExtraVarExt]}
{ExtraVarExt [lambda]}
{Type [int]}
{Type [char]}
{Type [boolean]}
{Type [ClassName]}
{SubroutineDec [SubroutineDecCFM SubroutineDecType SubroutineName ( ParameterList ) SubroutineBody SubroutineDec]}
{SubroutineDec [lambda]}
{SubroutineDecCFM [constructor]}
{SubroutineDecCFM [function]}
{SubroutineDecCFM [method]}
{SubroutineDecType [void]}
{SubroutineDecType [Type]}
{ParameterList [Type VarName ParameterListExt]}
{ParameterList [lambda]}
{ParameterListExt [, Type VarName ParameterListExt]}
{ParameterListExt [lambda]}
{SubroutineBody [{ SubroutineBodyVarDec Statements }]}
{SubroutineBodyVarDec [VarDec SubroutineBodyVarDec]}
{SubroutineBodyVarDec [lambda]}
{VarDec [var Type VarName VarDecExt ;]}
{VarDecExt [, VarName VarDecExt]}
{VarDecExt [lambda]}
{ClassName [identifier]}
{SubroutineName [subroutinename]}
{VarName [identifier]}
{VarName [array [ Expression ]]}
{Statements [Statement Statements]}
{Statements [lambda]}
{Statement [LetStatement]}
{Statement [IfStatement]}
{Statement [WhileStatement]}
{Statement [DoStatement]}
{Statement [ReturnStatement]}
{LetStatement [let VarName LetExpressionCheck = Expression ;]}
{LetExpressionCheck [[ Expression ]]}
{LetExpressionCheck [lambda]}
{IfStatement [if ( Expression ) { Statements } IfElseCheck]}
{IfElseCheck [else { Statements }]}
{IfElseCheck [lambda]}
{WhileStatement [while ( Expression ) { Statements }]}
{DoStatement [do SubroutineCall ;]}
{ReturnStatement [return ReturnExpressionCheck ;]}
{ReturnExpressionCheck [Expression]}
{ReturnExpressionCheck [lambda]}
{Expression [Term ExpressionTerms]}
{ExpressionTerms [Op Term ExpressionTerms]}
{ExpressionTerms [lambda]}
{Term [integerconstant]}
{Term [stringconstant]}
{Term [KeywordConstant]}
{Term [VarName]}
{Term [SubroutineCall]}
{Term [( Expression )]}
{Term [UnaryOp Term]}
{SubroutineCall [SubroutineName ( ExpressionList )]}
{SubroutineCall [SubroutineCallName . SubroutineName ( ExpressionList )]}
{SubroutineCallName [objectname]}
{ExpressionList [Expression ExpressionListExt]}
{ExpressionList [lambda]}
{ExpressionListExt [, Expression ExpressionListExt]}
{ExpressionListExt [lambda]}
{Op [+]}
{Op [-]}
{Op [*]}
{Op [/]}
{Op [&]}
{Op [pipe]}
{Op [<]}
{Op [>]}
{Op [=]}
{UnaryOp [-]}
{UnaryOp [~]}
{KeywordConstant [true]}
{KeywordConstant [false]}
{KeywordConstant [null]}
{KeywordConstant [this]}
++++++++++++
Class

] derv-> false
return derv-> false
function derv-> false
SubroutineDecType derv-> false
char derv-> false
method derv-> false
SubroutineName derv-> false
VarName derv-> false
subroutinename derv-> false
this derv-> false
, derv-> false
VarDecExt derv-> true
ClassVarDec derv-> true
false derv-> false
} derv-> false
IfElseCheck derv-> true
SubroutineCallName derv-> false
$ derv-> false
else derv-> false
. derv-> false
int derv-> false
; derv-> false
class derv-> false
) derv-> false
objectname derv-> false
var derv-> false
KeywordConstant derv-> false
DoStatement derv-> false
null derv-> false
/ derv-> false
do derv-> false
boolean derv-> false
Type derv-> false
WhileStatement derv-> false
ReturnStatement derv-> false
- derv-> false
static derv-> false
integerconstant derv-> false
ExtraVarExt derv-> true
ClassVarDecSF derv-> false
SubroutineDecCFM derv-> false
< derv-> false
SubroutineBodyVarDec derv-> true
ExpressionListExt derv-> true
ParameterListExt derv-> true
LetExpressionCheck derv-> true
stringconstant derv-> false
~ derv-> false
array derv-> false
Op derv-> false
SubroutineBody derv-> false
SubroutineCall derv-> false
field derv-> false
( derv-> false
> derv-> false
void derv-> false
VarDec derv-> false
ExpressionTerms derv-> true
if derv-> false
pipe derv-> false
ExpressionList derv-> true
UnaryOp derv-> false
ReturnExpressionCheck derv-> true
LetStatement derv-> false
while derv-> false
{ derv-> false
constructor derv-> false
* derv-> false
IfStatement derv-> false
Statement derv-> false
identifier derv-> false
[ derv-> false
let derv-> false
Statements derv-> true
Class derv-> false
true derv-> false
+ derv-> false
Term derv-> false
SubroutineDec derv-> true
ClassName derv-> false
& derv-> false
= derv-> false
ParameterList derv-> true
Expression derv-> false

first-> SubroutineName [subroutinename]
first-> VarName [identifier array]
first-> ClassVarDec [static field]
first-> VarDecExt [,]
first-> IfElseCheck [else]
first-> SubroutineCallName [objectname]
first-> KeywordConstant [null this true false]
first-> DoStatement [do]
first-> Type [identifier int char boolean]
first-> ClassVarDecSF [static field]
first-> SubroutineDecCFM [constructor function method]
first-> WhileStatement [while]
first-> ReturnStatement [return]
first-> ExtraVarExt [,]
first-> LetExpressionCheck [[]
first-> SubroutineBodyVarDec [var]
first-> ExpressionListExt [,]
first-> ParameterListExt [,]
first-> SubroutineBody [{]
first-> SubroutineCall [subroutinename objectname]
first-> Op [& pipe < > - * = + /]
first-> VarDec [var]
first-> ExpressionTerms [pipe + * / & < > = -]
first-> ReturnExpressionCheck [false this identifier array - ~ stringconstant true subroutinename objectname ( integerconstant null]
first-> LetStatement [let]
first-> ExpressionList [( ~ integerconstant false identifier subroutinename objectname - stringconstant true null this array]
first-> UnaryOp [~ -]
first-> IfStatement [if]
first-> Statement [while do return let if]
first-> Class [class]
first-> Statements [let if while do return]
first-> ClassName [identifier]
first-> Term [integerconstant true null - objectname ( stringconstant false this identifier array subroutinename ~]
first-> SubroutineDec [constructor function method]
first-> ParameterList [int char boolean identifier]
first-> Expression [integerconstant true null this subroutinename objectname ( ~ stringconstant false identifier array -]
first-> SubroutineDecType [char boolean identifier void int]

follow-> ExpressionList [)]
follow-> Type [identifier array subroutinename]
follow-> Op [array objectname - integerconstant subroutinename stringconstant null true false this ( identifier ~]
follow-> UnaryOp [- true false identifier array objectname integerconstant this subroutinename ( stringconstant null ~]
follow-> ExtraVarExt [;]
follow-> SubroutineDecType [subroutinename]
follow-> ParameterList [)]
follow-> SubroutineBody [constructor function method]
follow-> SubroutineBodyVarDec [} while do return let if]
follow-> KeywordConstant [& + < - pipe / = * >]
follow-> Expression [; ) , ]]
follow-> ReturnExpressionCheck [;]
follow-> ExpressionListExt [)]
follow-> ClassVarDecSF [boolean identifier int char]
follow-> IfStatement [let if while do return]
follow-> DoStatement [if while do return let]
follow-> IfElseCheck [return let if while do]
follow-> Term [* & pipe + - / < > =]
follow-> SubroutineDec [}]
follow-> VarName [[ = + < , - & ; pipe / > *]
follow-> SubroutineName [(]
follow-> VarDecExt [;]
follow-> SubroutineDecCFM [int char boolean identifier void]
follow-> ParameterListExt [)]
follow-> VarDec [var]
follow-> Statement [if while do return let]
follow-> LetStatement [do return let if while]
follow-> LetExpressionCheck [=]
follow-> SubroutineCall [& > ; = * < - / + pipe]
follow-> Class []
follow-> ClassName [subroutinename array identifier {]
follow-> ClassVarDec [function method } constructor]
follow-> Statements [}]
follow-> WhileStatement [let if while do return]
follow-> ReturnStatement [let if while do return]
follow-> ExpressionTerms [, ) ] ;]
follow-> SubroutineCallName [.]

predict-> {Class [class ClassName { ClassVarDec SubroutineDec } $]} [class]
predict-> {ClassVarDec [ClassVarDecSF Type VarName ExtraVarExt ; ClassVarDec]} [static field]
predict-> {ClassVarDec [lambda]} [function } method constructor]
predict-> {ClassVarDecSF [static]} [static]
predict-> {ClassVarDecSF [field]} [field]
predict-> {ExtraVarExt [, VarName ExtraVarExt]} [,]
predict-> {ExtraVarExt [lambda]} [;]
predict-> {Type [int]} [int]
predict-> {Type [char]} [char]
predict-> {Type [boolean]} [boolean]
predict-> {Type [ClassName]} [identifier]
predict-> {SubroutineDec [SubroutineDecCFM SubroutineDecType SubroutineName ( ParameterList ) SubroutineBody SubroutineDec]} [method constructor function]
predict-> {SubroutineDec [lambda]} [}]
predict-> {SubroutineDecCFM [constructor]} [constructor]
predict-> {SubroutineDecCFM [function]} [function]
predict-> {SubroutineDecCFM [method]} [method]
predict-> {SubroutineDecType [void]} [void]
predict-> {SubroutineDecType [Type]} [int char boolean identifier]
predict-> {ParameterList [Type VarName ParameterListExt]} [identifier int char boolean]
predict-> {ParameterList [lambda]} [)]
predict-> {ParameterListExt [, Type VarName ParameterListExt]} [,]
predict-> {ParameterListExt [lambda]} [)]
predict-> {SubroutineBody [{ SubroutineBodyVarDec Statements }]} [{]
predict-> {SubroutineBodyVarDec [VarDec SubroutineBodyVarDec]} [var]
predict-> {SubroutineBodyVarDec [lambda]} [let if } while do return]
predict-> {VarDec [var Type VarName VarDecExt ;]} [var]
predict-> {VarDecExt [, VarName VarDecExt]} [,]
predict-> {VarDecExt [lambda]} [;]
predict-> {ClassName [identifier]} [identifier]
predict-> {SubroutineName [subroutinename]} [subroutinename]
predict-> {VarName [identifier]} [identifier]
predict-> {VarName [array [ Expression ]]} [array]
predict-> {Statements [Statement Statements]} [do return let if while]
predict-> {Statements [lambda]} [}]
predict-> {Statement [LetStatement]} [let]
predict-> {Statement [IfStatement]} [if]
predict-> {Statement [WhileStatement]} [while]
predict-> {Statement [DoStatement]} [do]
predict-> {Statement [ReturnStatement]} [return]
predict-> {LetStatement [let VarName LetExpressionCheck = Expression ;]} [let]
predict-> {LetExpressionCheck [[ Expression ]]} [[]
predict-> {LetExpressionCheck [lambda]} [=]
predict-> {IfStatement [if ( Expression ) { Statements } IfElseCheck]} [if]
predict-> {IfElseCheck [else { Statements }]} [else]
predict-> {IfElseCheck [lambda]} [let if while do return]
predict-> {WhileStatement [while ( Expression ) { Statements }]} [while]
predict-> {DoStatement [do SubroutineCall ;]} [do]
predict-> {ReturnStatement [return ReturnExpressionCheck ;]} [return]
predict-> {ReturnExpressionCheck [Expression]} [identifier stringconstant false objectname ( subroutinename this array - null ~ integerconstant true]
predict-> {ReturnExpressionCheck [lambda]} [;]
predict-> {Expression [Term ExpressionTerms]} [this subroutinename ( identifier integerconstant array objectname ~ true false - stringconstant null]
predict-> {ExpressionTerms [Op Term ExpressionTerms]} [/ > & * = + - pipe <]
predict-> {ExpressionTerms [lambda]} [; , ) ]]
predict-> {Term [integerconstant]} [integerconstant]
predict-> {Term [stringconstant]} [stringconstant]
predict-> {Term [KeywordConstant]} [null this true false]
predict-> {Term [VarName]} [identifier array]
predict-> {Term [SubroutineCall]} [subroutinename objectname]
predict-> {Term [( Expression )]} [(]
predict-> {Term [UnaryOp Term]} [~ -]
predict-> {SubroutineCall [SubroutineName ( ExpressionList )]} [subroutinename]
predict-> {SubroutineCall [SubroutineCallName . SubroutineName ( ExpressionList )]} [objectname]
predict-> {SubroutineCallName [objectname]} [objectname]
predict-> {ExpressionList [Expression ExpressionListExt]} [objectname ~ stringconstant null this - integerconstant true subroutinename ( false identifier array]
predict-> {ExpressionList [lambda]} [)]
predict-> {ExpressionListExt [, Expression ExpressionListExt]} [,]
predict-> {ExpressionListExt [lambda]} [)]
predict-> {Op [+]} [+]
predict-> {Op [-]} [-]
predict-> {Op [*]} [*]
predict-> {Op [/]} [/]
predict-> {Op [&]} [&]
predict-> {Op [pipe]} [pipe]
predict-> {Op [<]} [<]
predict-> {Op [>]} [>]
predict-> {Op [=]} [=]
predict-> {UnaryOp [-]} [-]
predict-> {UnaryOp [~]} [~]
predict-> {KeywordConstant [true]} [true]
predict-> {KeywordConstant [false]} [false]
predict-> {KeywordConstant [null]} [null]
predict-> {KeywordConstant [this]} [this]
map[1:{Class [class ClassName { ClassVarDec SubroutineDec } $]} 2:{ClassVarDec [ClassVarDecSF Type VarName ExtraVarExt ; ClassVarDec]} 3:{ClassVarDec [lambda]} 4:{ClassVarDecSF [static]} 5:{ClassVarDecSF [field]} 6:{ExtraVarExt [, VarName ExtraVarExt]} 7:{ExtraVarExt [lambda]} 8:{Type [int]} 9:{Type [char]} 10:{Type [boolean]} 11:{Type [ClassName]} 12:{SubroutineDec [SubroutineDecCFM SubroutineDecType SubroutineName ( ParameterList ) SubroutineBody SubroutineDec]} 13:{SubroutineDec [lambda]} 14:{SubroutineDecCFM [constructor]} 15:{SubroutineDecCFM [function]} 16:{SubroutineDecCFM [method]} 17:{SubroutineDecType [void]} 18:{SubroutineDecType [Type]} 19:{ParameterList [Type VarName ParameterListExt]} 20:{ParameterList [lambda]} 21:{ParameterListExt [, Type VarName ParameterListExt]} 22:{ParameterListExt [lambda]} 23:{SubroutineBody [{ SubroutineBodyVarDec Statements }]} 24:{SubroutineBodyVarDec [VarDec SubroutineBodyVarDec]} 25:{SubroutineBodyVarDec [lambda]} 26:{VarDec [var Type VarName VarDecExt ;]} 27:{VarDecExt [, VarName VarDecExt]} 28:{VarDecExt [lambda]} 29:{ClassName [identifier]} 30:{SubroutineName [subroutinename]} 31:{VarName [identifier]} 32:{VarName [array [ Expression ]]} 33:{Statements [Statement Statements]} 34:{Statements [lambda]} 35:{Statement [LetStatement]} 36:{Statement [IfStatement]} 37:{Statement [WhileStatement]} 38:{Statement [DoStatement]} 39:{Statement [ReturnStatement]} 40:{LetStatement [let VarName LetExpressionCheck = Expression ;]} 41:{LetExpressionCheck [[ Expression ]]} 42:{LetExpressionCheck [lambda]} 43:{IfStatement [if ( Expression ) { Statements } IfElseCheck]} 44:{IfElseCheck [else { Statements }]} 45:{IfElseCheck [lambda]} 46:{WhileStatement [while ( Expression ) { Statements }]} 47:{DoStatement [do SubroutineCall ;]} 48:{ReturnStatement [return ReturnExpressionCheck ;]} 49:{ReturnExpressionCheck [Expression]} 50:{ReturnExpressionCheck [lambda]} 51:{Expression [Term ExpressionTerms]} 52:{ExpressionTerms [Op Term ExpressionTerms]} 53:{ExpressionTerms [lambda]} 54:{Term [integerconstant]} 55:{Term [stringconstant]} 56:{Term [KeywordConstant]} 57:{Term [VarName]} 58:{Term [SubroutineCall]} 59:{Term [( Expression )]} 60:{Term [UnaryOp Term]} 61:{SubroutineCall [SubroutineName ( ExpressionList )]} 62:{SubroutineCall [SubroutineCallName . SubroutineName ( ExpressionList )]} 63:{SubroutineCallName [objectname]} 64:{ExpressionList [Expression ExpressionListExt]} 65:{ExpressionList [lambda]} 66:{ExpressionListExt [, Expression ExpressionListExt]} 67:{ExpressionListExt [lambda]} 68:{Op [+]} 69:{Op [-]} 70:{Op [*]} 71:{Op [/]} 72:{Op [&]} 73:{Op [pipe]} 74:{Op [<]} 75:{Op [>]} 76:{Op [=]} 77:{UnaryOp [-]} 78:{UnaryOp [~]} 79:{KeywordConstant [true]} 80:{KeywordConstant [false]} 81:{KeywordConstant [null]} 82:{KeywordConstant [this]}]
[Class ClassVarDec ClassVarDecSF ExtraVarExt Type SubroutineDec SubroutineDecCFM SubroutineDecType ParameterList ParameterListExt SubroutineBody SubroutineBodyVarDec VarDec VarDecExt ClassName SubroutineName VarName Statements Statement LetStatement LetExpressionCheck IfStatement IfElseCheck WhileStatement DoStatement ReturnStatement ReturnExpressionCheck Expression ExpressionTerms Term SubroutineCall SubroutineCallName ExpressionList ExpressionListExt Op UnaryOp KeywordConstant]
[& ( ) * + , - . / ; < = > [ ] array boolean char class constructor do else false field function identifier if int integerconstant let method null objectname pipe return static stringconstant subroutinename this true var void while { } ~ $]
map[$:46 &:0 (:1 ):2 *:3 +:4 ,:5 -:6 .:7 /:8 ;:9 <:10 =:11 >:12 [:13 ]:14 array:15 boolean:16 char:17 class:18 constructor:19 do:20 else:21 false:22 field:23 function:24 identifier:25 if:26 int:27 integerconstant:28 let:29 method:30 null:31 objectname:32 pipe:33 return:34 static:35 stringconstant:36 subroutinename:37 this:38 true:39 var:40 void:41 while:42 {:43 }:44 ~:45]
map[Class:0 ClassName:14 ClassVarDec:1 ClassVarDecSF:2 DoStatement:24 Expression:27 ExpressionList:32 ExpressionListExt:33 ExpressionTerms:28 ExtraVarExt:3 IfElseCheck:22 IfStatement:21 KeywordConstant:36 LetExpressionCheck:20 LetStatement:19 Op:34 ParameterList:8 ParameterListExt:9 ReturnExpressionCheck:26 ReturnStatement:25 Statement:18 Statements:17 SubroutineBody:10 SubroutineBodyVarDec:11 SubroutineCall:30 SubroutineCallName:31 SubroutineDec:5 SubroutineDecCFM:6 SubroutineDecType:7 SubroutineName:15 Term:29 Type:4 UnaryOp:35 VarDec:12 VarDecExt:13 VarName:16 WhileStatement:23]

[& ( ) * + , - . / ; < = > [ ] array boolean char class constructor do else false field function identifier if int integerconstant let method null objectname pipe return static stringconstant subroutinename this true var void while { } ~ $]
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 2 3 0 0 0 0 0 3 0 0 0 0 2 0 0 0 0 0 0 0 0 3 0 0]
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 0 0 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 6 0 0 0 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 10 9 0 0 0 0 0 0 0 11 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 12 0 0 0 0 12 0 0 0 0 0 12 0 0 0 0 0 0 0 0 0 0 0 0 0 13 0 0]
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 14 0 0 0 0 15 0 0 0 0 0 16 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 18 18 0 0 0 0 0 0 0 18 0 18 0 0 0 0 0 0 0 0 0 0 0 0 0 17 0 0 0 0 0]
[0 0 20 0 0 0 0 0 0 0 0 0 0 0 0 0 19 19 0 0 0 0 0 0 0 19 0 19 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
[0 0 22 0 0 21 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 23 0 0 0]
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 25 0 0 0 0 0 25 0 0 25 0 0 0 0 25 0 0 0 0 0 24 0 25 0 25 0 0]
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 26 0 0 0 0 0 0]
[0 0 0 0 0 27 0 0 0 28 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 29 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 30 0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 32 0 0 0 0 0 0 0 0 0 31 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 33 0 0 0 0 0 33 0 0 33 0 0 0 0 33 0 0 0 0 0 0 0 33 0 34 0 0]
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 38 0 0 0 0 0 36 0 0 35 0 0 0 0 39 0 0 0 0 0 0 0 37 0 0 0 0]
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 40 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 0 0 0 0 0 0 42 0 41 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 43 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 45 44 0 0 0 0 45 0 0 45 0 0 0 0 45 0 0 0 0 0 0 0 45 0 0 0 0]
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 46 0 0 0 0]
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 47 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 48 0 0 0 0 0 0 0 0 0 0 0 0]
[0 49 0 0 0 0 49 0 0 50 0 0 0 0 0 49 0 0 0 0 0 0 49 0 0 49 0 0 49 0 0 49 49 0 0 0 49 49 49 49 0 0 0 0 0 49 0]
[0 51 0 0 0 0 51 0 0 0 0 0 0 0 0 51 0 0 0 0 0 0 51 0 0 51 0 0 51 0 0 51 51 0 0 0 51 51 51 51 0 0 0 0 0 51 0]
[52 0 53 52 52 53 52 0 52 53 52 52 52 0 53 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 52 0 0 0 0 0 0 0 0 0 0 0 0 0]
[0 59 0 0 0 0 60 0 0 0 0 0 0 0 0 57 0 0 0 0 0 0 56 0 0 57 0 0 54 0 0 56 58 0 0 0 55 58 56 56 0 0 0 0 0 60 0]
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 62 0 0 0 0 61 0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 63 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
[0 64 65 0 0 0 64 0 0 0 0 0 0 0 0 64 0 0 0 0 0 0 64 0 0 64 0 0 64 0 0 64 64 0 0 0 64 64 64 64 0 0 0 0 0 64 0]
[0 0 67 0 0 66 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
[72 0 0 70 68 0 69 0 71 0 74 76 75 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 73 0 0 0 0 0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 0 77 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 78 0]
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 80 0 0 0 0 0 0 0 0 81 0 0 0 0 0 0 82 79 0 0 0 0 0 0 0]
=======================LL table driven parsing============
---------------
{$ $}
------
data ROOT 0
children->[]
S: [Class]
Q: [{$ $}]
Parsing Error: (No such token in LL table or associated rule) Class $ [{$ $}]
-----
Class [Class]
